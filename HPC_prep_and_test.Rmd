---
title: "HPC prep and test"
author: "Jonathan Bourne"
date: "27/11/2019"
output: html_document
editor_options: 
  chunk_output_type: console
---

This markdown contains the code that is used to feed the HPC as well as the post HPC processing

#base code for running the hpc
~/Spring_Embeddings_Paper/bash_scripts/bash_script_concentrator/qsub_custom IEEE_300_igraph bigautostrain2 20:00:00
~/Spring_Embeddings_Paper/bash_scripts/bash_script_concentrator/qsub_custom UK_high_voltage bigautostrain2 00:10:00

~/Spring_Embeddings_Paper/bash_scripts/bash_script_concentrator/qsub_custom UK_high_voltage attack 20:00:00
##code for making the bash file runnable
chmod +x /path/to/your/filename.extension

#Set up
```{r}
packages <- c("rlang", "tidyverse", "igraph", "devtools", "minpack.lm", "ggraph", "yardstick", "Matrix")

new.packages <- packages[!(packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)

sapply(packages, library, character.only = TRUE)

#install_github("JonnoB/PowerGridNetworking")
library(PowerGridNetworking)
library(NetworkSpringEmbedding)

#Set up file system to read the correct folders this switches between aws and windows mode

#creates the correct root depending on whether this is on the cloud or not
if(dir.exists("/home/jonno")){
  #This folder is for use on my machine
  project_folder <- "/home/jonno/Dropbox/IEEE_Networks"
  basewd <- "/home/jonno"
}else{
  #This is for the folder that is on the cloud
  project_folder <- "~/Dropbox/IEEE_Networks"
  basewd <- "~/Dropbox"
}

power_grid_graphs_path <- file.path(project_folder, "power_grid_graphs") #The path where the base igraph representations of the power grids are
collapse_sets_path <- file.path(project_folder, "collapse_sets") #the full collapse set of each power grid and the permutations are stored here
collapse_set_summaries_path <- file.path(project_folder, "collapse_set_summaries")
permuted_IEEE_118_path <- file.path(power_grid_graphs_path, "Permuted_IEEE_118") #The permuted base IEEE-118 igraphs are stored here
pl_IEEE_path <- file.path(power_grid_graphs_path, "pl_IEEE") 
edge_scramble_keys_path <- file.path(project_folder, "edge_scramble_keys")
edge_scramble_keys_IEEE_permutation_path <- file.path(edge_scramble_keys_path, "Permuted_IEEE_118")
analysis_parameter_file_path <- file.path(project_folder, "analysis_parameter_files")
HPC_startup_parameter_file_path <- file.path(project_folder, "HPC_parameter_files")
embeddings_path <- file.path(project_folder, "embeddings") 

#make sure all the paths exist
#this is really annoying as it keeps making folders in the home directory
# ls(pattern = "_path") %>% walk(~{
#   if(!file.exists(.x)) dir.create(.x, recursive = T)
# })

#Load some other useful functions
list.files(file.path(basewd, "Useful_PhD__R_Functions"), pattern = ".R", full.names = T) %>%
  walk(~source(.x))

# list.files(file.path(basewd, "NetworkSpringEmbedding/R"), pattern = ".R", full.names = T) %>%
#   walk(~source(.x))

```

#test brain graphs
http://braingraph.org/cms/download-pit-group-connectomes/
```{r}

brains <- list.files("/home/jonno/Downloads/repeated_10_scale_60", full.names = T)
test <-read_graph(brains[2], format = "graphml")

ggraph(test, layout = layout_with_fr(test)) +
   geom_edge_link2(aes(colour = FA_mean)) +
  scale_edge_colour_viridis() +
  geom_node_point( aes(colour = betweenness(test) ),
                   size = 2.5) 


edge_attr(test)

as_data_frame(test ) %>% tibble %>%
  ggplot(aes(x = number_of_fibers)) +geom_density()


```



#Load IEEE network
This loads a network ready to be attacked or embedded
```{r}

g <- readRDS(file.path(power_grid_graphs_path,  paste0("IEEE_", 118, "_igraph.rds"))) %>%
                Proportional_Load(., 5, PowerFlow = "power_flow", Link.Limit = "edge_capacity") %>%
                set.edge.attribute(. , "distance", value = 1) %>%
        set.edge.attribute(., "Area", value = 1) %>%
        calc_spring_youngs_modulus(., "power_flow", "edge_capacity", minimum_value = 10000, stretch_range = 1000) %>%
        calc_spring_constant(., E ="E", A = "Area", distance = "distance") %>%
        normalise_dc_load(.,  
                           generation = "generation", 
                           demand  = "demand",
                           net_generation = "net_generation", 
                           capacity = "edge_capacity",
                           edge_name = "edge_name", 
                           node_name = "name",
                           power_flow = "power_flow")

```


##Run collapse script

```{r}
#If this is put in a loop or walk mapping then it will "arguably" calculate the data for all the maps and systems
#Load the params file. 

#Load the params file. 

#This appears to be considerably faster than the parallel version
1:nrow(288) %>% walk(~{
  
  task_id <- .x #this is the compute group to be used
  
  load_file <- "IEEE_14_igraph"

  source(file.path("/home/jonno/setse_and_network_robustness/HPC_files/HPC_files_concentrator", 
                   "HPC_attack_concentrator_script.R"), local = TRUE)
  
  return(NULL)
  
} )


#untar the HPX files
list.files("/home/jonno/HPC_jobs/attack", full.names = T) %>% walk(~{
  
  list.files(.x, pattern = ".tgz", full.names = T) %>% 
    walk(~{
      untar(tarfile = .x, 
            exdir = "/home/jonno/Dropbox/IEEE_Networks/attacks",#, 
            extras = "--strip-components 4"  #take only the useful bits of the zip file
      )
      
    })
  
})

#Identify missing files, That for some reason did not end up on the HPC
completed_collapses <- tibble(file_path = list.files("/home/jonno/Dropbox/IEEE_Networks/attacks", full.names = T, recursive = T),
       file_name = basename(file_path),
       graph = dirname(file_path)%>% basename(),
       task_id = str_remove(file_name, "task_id_") %>% str_remove(., ".rds") %>% as.integer(.))

missing_collapses <-expand_grid(graph = unique(completed_collapses$graph),
                            task_id = 1:288) %>%
  left_join(completed_collapses) %>%
  filter(!complete.cases(.))

#run the collapse analysis will all the missing elements
 walk2(.x = missing_collapses$task_id, .y = missing_collapses$graph, ~{
  
  task_id <- .x #this is the compute group to be used
  
  load_file <- .y

  source(file.path("/home/jonno/setse_and_network_robustness/HPC_files/HPC_files_concentrator", 
                   "HPC_attack_concentrator_script.R"), local = TRUE)
  
  return(NULL)
  
} )

```

##Run Strain script
```{r}
#If this is put in a loop or walk mapping then it will "arguably" calculate the data for all the maps and systems
#Load the params file. 


#This appears to be considerably faster than the parallel version
1:nrow(3456) %>% walk(~{
  
  task_id <- .x #this is the compute group to be used
  
  load_file <- "IEEE_118_igraph"

  source(file.path("/home/jonno/Spring_Embeddings_Paper", "HPC_strain_script.R"), local = TRUE)
  
  return(NULL)
  
} )


```


##Test r and c script

This tests to see if the system diverges for all the test r and c values using the most extreme cases of 1 and infinity

The results of this test allow me to set the simulation parameters  for the r c test on IEEE118. This means I can run the test on the HPC and hopefully not have too many failed simulations

question: if I do a 100 by 100 raster of r and c for single edge, and also do it for a real network, what do the differences mean or look like?

```{r}

1:1 %>% walk(~{
  
  task_id <- .x #this is the compute group to be used
  
  load_file <- "IEEE_118_igraph"

  source(file.path("/home/jonno/setse_and_network_robustness/HPC_files/HPC_PL", "HPC_pl_strain_test_r_c.R"), 
         local = TRUE)
  
  return(NULL)
  
} )


r_c_test_node_df <- list.files("/home/jonno/Dropbox/IEEE_Networks/embeddings/PL_IEEE_118_igraph") %>%
  map_df(~{
    print(.x)
    parts <-str_remove(.x, ".rds") %>%
      str_split(., "_", simplify = T)
    Out <- read_rds(file.path("/home/jonno/Dropbox/IEEE_Networks/embeddings/PL_IEEE_118_igraph", .x))$node_embeddings %>%
      mutate(
        ec = as.numeric(parts[2]),
        r = as.integer(parts[4]),
        c = as.integer(parts[6]))
    
    return(Out)
    
  }
  ) 

r_c_test_df <- list.files("/home/jonno/Dropbox/IEEE_Networks/embeddings/PL_IEEE_118_igraph") %>%
  map_df(~{
    print(.x)
    parts <-str_remove(.x, ".rds") %>%
      str_split(., "_", simplify = T)
    Out <- read_rds(file.path("/home/jonno/Dropbox/IEEE_Networks/embeddings/PL_IEEE_118_igraph", .x))$edge_embeddings %>%
      mutate(
        ec = as.numeric(parts[2]),
        r = as.integer(parts[4]),
        c = as.integer(parts[6]))
    
    return(Out)
    
  }
  )

r_c_dynamics_df <- list.files("/home/jonno/Dropbox/IEEE_Networks/embeddings/PL_IEEE_118_igraph")%>%
  map_df(~{
    #print(.x)
    parts <-str_remove(.x, ".rds") %>%
      str_split(., "_", simplify = T)
    Out <- read_rds(
      file.path("/home/jonno/Dropbox/IEEE_Networks/embeddings/PL_IEEE_118_igraph", .x))$network_dynamics %>% 
      summarise_all(last) %>%
      #slice(5e3) %>%
      mutate(
        ec = as.numeric(parts[2]),
        r = as.integer(parts[4]),
        c = as.integer(parts[6]),
        tstep = as.numeric(parts[8]),
        coef_drag = as.numeric(parts[11]))
    
    return(Out)
    
  }
  ) %>%
  mutate(total_energy = potential_energy + kinetic_energy,
         combo = paste(r,c, sep = "_"))

#at the point of convergence
r_c_dynamics_df2 <- list.files("/home/jonno/Dropbox/IEEE_Networks/embeddings/PL_IEEE_118_igraph")%>%
  map_df(~{
    #print(.x)
    parts <-str_remove(.x, ".rds") %>%
      str_split(., "_", simplify = T)
    Out <- read_rds(
      file.path("/home/jonno/Dropbox/IEEE_Networks/embeddings/PL_IEEE_118_igraph", .x))$network_dynamics %>% 
      filter(static_force<=2e-3) %>%
      summarise_all(first) %>%
      #slice(5e3) %>%
      mutate(
        ec = as.numeric(parts[2]),
        r = as.integer(parts[4]),
        c = as.integer(parts[6]),
        tstep = as.numeric(parts[8]),
        coef_drag = as.numeric(parts[11]))
    
    return(Out)
    
  }
  ) %>%
  mutate(total_energy = potential_energy + kinetic_energy,
         combo = paste(r,c, sep = "_"))


#look at the last element of the RC data frame for each simulation
#discard non converged values
r_c_dynamics_df %>%
  filter((static_force)<2e-3, total_energy<1) %>%
  ggplot(aes(x = log10(static_force+kinetic_force), y = total_energy, colour = factor(coef_drag))) + geom_point() +
    facet_grid(r~c)


  r_c_dynamics_df %>%
  filter(ec ==1) %>%
  mutate(converged = (static_force)<1e-3,
         total_force = static_force+kinetic_force) %>%
  ggplot(aes(x= factor(coef_drag, levels= unique(coef_drag)), y = factor(tstep), fill = converged)) +
  geom_raster() +
    facet_grid(r~c)
  
  #It is easier to converge large numbers to low force levels, however, large force levels are more likely to diverge!
  #When ec is 1 the rasters are all dependent on c alone as the k value is c
  #When the ec value is Inf the rasters are dependent on both r and c
  ec_val <- Inf
  convergance_raster_prep <-   r_c_dynamics_df %>%
  #    filter(r == 1, c == 1) %>%
  mutate(converged = static_force<2e-3,
         static_force = ifelse(static_force>2e1, NA, static_force), #If the static force exceeds the threshold set to that threshold. This prevents large ranges when trying to plot colour
         total_force = static_force+kinetic_force,
         total_force = ifelse(total_force<1, total_force, NA)) 
      
     convergance_raster_prep  %>%
  filter(ec ==ec_val,
         #static_force<2e-3
         ) %>%
  ggplot(aes(x= factor(coef_drag), 
             y = factor(tstep, levels = unique(tstep)), 
             fill = log10(Iter))) +
  geom_raster() +
    facet_grid(r~c) + scale_fill_viridis_c() +
      labs(title = paste("residual force of 118 with PL of", ec_val,"across different r,c, tstep and drag values"),
           fill = "log static force",
           x = "drag",
           y = "time step")

 #These are the parameters that will converge for both 1 and Inf and that give the lowest static_force across all iterations
 #for 120k iterations.
 converging_parameters_df <- convergance_raster_prep %>%
   filter(r>=100, c >=100, !is.na(static_force)) %>%
    group_by(coef_drag, tstep, r,c) %>%
    summarise(converged = sum(converged),
              total = n(),
              min = min(static_force),
              max = max(static_force),
              max_kin = max(kinetic_force)) %>%
   filter(converged == 2) %>%
   group_by(r,c) %>%
   slice(which.min(max)) %>%
   ungroup
 
  converging_parameters_df %>%
   ungroup %>%
   select(1:4) %>% 
   mutate(compute_group_strain = as.integer(1:n())) %>%
   dput
 
 
 #linear relation between log static force and log kinetic energy/force
 convergance_raster_prep %>%
   filter(!is.na(static_force)) %>%
    filter(r>=100, c >=100) %>%
   ggplot(aes(x = log10(static_force), y = log10(kinetic_energy), colour = as.factor(paste(coef_drag)))) + 
   geom_point()

 


tension_strain_relationship <- r_c_test_df %>%
  select(tension:c ) %>%
  select(-percentile_strain) %>%
  group_by(ec, r,c) %>% 
  summarise_all(list(mean =mean, median = median,min =  min, max =  max))

tension_strain_relationship %>%
  mutate(ratio = strain_mean/tension_mean) %>%
 # filter(ec == Inf) %>%
ggplot(., aes(x = as.factor(r), y = as.factor(c), fill = tension_mean)) + geom_raster() +
  facet_grid(~ec) +
  scale_fill_viridis_c(option = "B")



#Rows are r and columns are c.
#r/c ratio determins the maximum energy range in the network the larger the ratio the bigger the gap
#also the larger c the lower the absolute amount of the energy in the system
#also 
r_c_dynamics_df %>%
   filter((round(t/0.01)%%100)==0,
  #  paste(r,c)!="10000 10000",
  #  t>580
         ) %>%
  ggplot(aes(x = t, y = log10(total_energy), colour = as.factor(ec))) + geom_line()+
  facet_grid(r~c)



r_c_dynamics_df %>%
   filter((round(t/0.01)%%100)==0,
  #  paste(r,c)!="10000 10000",
  #  t>580
         ) %>%
ggplot(aes(x = (t), y =log10(static_force), colour =  factor(ec))) + geom_line()+
  facet_grid(c~r)


combined_summary <-r_c_test_node_df %>%
  group_by(ec,r,c) %>%
  summarise(kinetic_energy = sum(kinetic_energy),
          force_energy = sum(abs(NetForce + friction))) 
  

combined_summary  %>%
   filter((round(t/tstep)%%100)==0,
         #t<10
       #  node %in% c(1,2)
         ) %>%
  ggplot(aes(x = log10(kinetic_energy), y = log10(potential_energy), colour = paste(r,c))) +geom_jitter()

test <- r_c_dynamics_df %>%
  #filter(ec ==1) %>%
  group_by(total_energy>4000, combo, ec) %>%
  summarise(counts = n())
  
test <- r_c_dynamics_df %>%
  filter(combo =="100_10000", ec==Inf)

#test the versions done on HPC
list.files("/home/jonno/test_strain/strainrc/IEEE_118_igraph", pattern = ".")
spec_file <- readRDS(file.path("/home/jonno/Dropbox/IEEE_Networks/embeddings/PL_IEEE_118_igraph", "ec_1_r_10000_c_10000_tstep_0.01_coef_drag_0.5.rds")  )


node_status <- spec_file$node_embeddings

dynamics <- spec_file$network_dynamics

dynamics %>%
  filter(Iter!=0)%>% #stops a line going up from 0
  filter(t>20) %>%
  #filter(static_force<10) %>%
  ggplot(aes(x = (t), y = log10(static_force))) + geom_line()
tail(dynamics)


     #This shows the convergence relationship for 
    convergance_raster_prep2 <-   r_c_dynamics_df2 %>%
  mutate(converged = static_force<2e-3,
         static_force = ifelse(static_force>2e1, NA, static_force), #If the static force exceeds the threshold set to that threshold. This prevents large ranges when trying to plot colour
         total_force = static_force+kinetic_force,
         total_force = ifelse(total_force<1, total_force, NA)) %>%
             select(Iter, r,c, ec, tstep, coef_drag, combo, static_force, kinetic_force) %>%
            filter(
       is.finite(Iter),
         static_force<=2e-3,
         ) %>%
       mutate(tstep_drag = tstep/coef_drag,
              rxc = log10(r*c),
              r_c = log10(r/c),
              rc = paste("r = ", r, "c=", c),
              ec = paste0("alpha_", ec),
              lgIter = log10(Iter),
              lgtstep_drag = log10(tstep_drag)
              )

    
    #The relationship between the ratio of the tstep and drag with the time to convergence
    convergance_raster_prep2 %>%
      ggplot(aes(
        y = log10(Iter), 
        x = log10(tstep_drag), 
        colour = rxc,
        linetype = factor(ec), 
        group = interaction(factor(ec), rc))) + 
      geom_line() +
      labs(title = "Ratio of time step size over coefficient of drag against iterations",
           y = "log10 Number of Iterations to convergence",
           x = "log10 timestep size divided by drag coefficient") +
      facet_wrap(~r_c) +
      scale_color_viridis_c()
          
          #Model coefficients
         model_coefs <- -4:4 %>%
            map_df(~{
              
              data_df <-  convergance_raster_prep2 %>% filter( r_c==.x)
              
              lm(lgIter~ lgtstep_drag + ec+ rxc , data = data_df ) %>%
                tidy %>% mutate(r_c = .x,
                                total_rxc = length(unique(data_df$rxc)))
              
            })
          
          #model performance
          model_perf <- -4:4 %>%
            map_df(~{
              
              
              lm(lgIter~ lgtstep_drag + ec+ rxc +r_c , data = convergance_raster_prep2 %>% filter( r_c==.x) ) %>%
                glance %>% mutate(r_c = .x)
              
            })
          
          
          #The most extreme r_c ratios have the least sucessful convergences
          #
          model_coefs %>%
            ggplot(aes(x = r_c, y = estimate, colour = factor(total_rxc))) + geom_point() +
            facet_wrap(~term, scales = "free_y")
          
          
          test <- convergance_raster_prep2 %>%
            group_by(r_c, rxc) %>%
            summarise(counts = n())
          #wot dis mean? can I fill in the gaps what does it even tell me apart from it is cool?
          test %>%
            ggplot(aes(x = r_c,y = rxc, fill = counts)) + geom_raster() +
            scale_fill_viridis_c()
          
          #This is a pretty clear pattern
          #It shows that the central rxc combo has the most examples of convergence in it
          test %>%
            group_by(rxc) %>%
            summarise(counts = n()) %>%
            ggplot(aes(x = rxc, y = counts)) + geom_col()

test <-list.files("/home/jonno/test_strain/strain_2533925.1/tmpdir/job/2533925.1/embeddings/IEEE_118_igraph", full.names = T)[7] %>%
  read_rds(.)

test1 <- test$node_embeddings
test2 <- test$edge_embeddings
test3 <- test$network_dynamics

```

#Test tstep and drag
This is similar to the above code except that it produces a more high def coef and drag plot for a single r c value
```{r}
  task_id <- 1 #this is the compute group to be used
  
  load_file <- "IEEE_118_igraph"

  source(file.path("/home/jonno/setse_and_network_robustness/HPC_files/HPC_PL", "HPC_pl_strain_test_drag_tstep.R"), 
         local = TRUE)
  
  
 file_path <-  "/home/jonno/Dropbox/IEEE_Networks/embeddings/PL_IEEE_118_igraph_tstep_drag"
  
  
  
  
tstep_drag_dynamics_df <- list.files(file_path)%>%
  map_df(~{
    #print(.x)
    parts <-str_remove(.x, ".rds") %>%
      str_split(., "_", simplify = T)
    Out <- read_rds(
      file.path(file_path, .x))$network_dynamics %>% 
      summarise_all(last) %>%
      #slice(5e3) %>%
      mutate(
        ec = as.numeric(parts[2]),
        r = as.integer(parts[4]),
        c = as.integer(parts[6]),
        tstep = as.numeric(parts[8]),
        coef_drag = as.numeric(parts[11]))
    
    return(Out)
    
  }
  ) %>%
  mutate(total_energy = potential_energy + kinetic_energy,
         converged = static_force < 2e-3)



unique(tstep_drag_dynamics_df$c)

  tstep_drag_dynamics_df %>%
  filter(c ==100,
         r== 1e4) %>%
  mutate(converged = (static_force)<=2e-3,
         total_force = static_force+kinetic_force) %>%
  ggplot(aes(x= factor(coef_drag, levels= unique(coef_drag)), y = factor(tstep), fill = converged)) +
  geom_raster() 
  
  #It is easier to converge large numbers to low force levels, however, large force levels are more likely to diverge!

  ec_val <- Inf
  convergance_raster_prep <-   tstep_drag_dynamics_df%>%
  #    filter(r == 1, c == 1) %>%
  mutate(converged = static_force < 2e-3,
     #    static_force = ifelse(static_force > 2e1, NA, static_force), #If the static force exceeds the threshold set to that threshold. This prevents large ranges when trying to plot colour
         total_force = static_force+kinetic_force,
         total_force = ifelse(total_force<1, total_force, NA)) 
      
     convergance_raster_prep  %>%
  filter(ec ==ec_val,
         static_force<=2e-3,
         c ==100,
         r== 1e4) %>%
  ggplot(aes(x= factor(coef_drag), 
             y = factor(tstep, levels = unique(tstep)), 
             fill = (Iter))) +
  geom_raster() + scale_fill_viridis_c() +
      labs(title = paste("residual force of 118 with PL of", ec_val,"across different r,c, tstep and drag values"),
           fill = "log10 Iterations to convergence",
           x = "drag",
           y = "time step")
     
     convergance_raster_prep %>% filter(
       #ec ==ec_val,
         static_force<=2e-3,
       #  c ==100,
        # r== 1e4
         ) %>%
       mutate(ratio = tstep/coef_drag,
              rc = paste("r = ", r, "c=", c)) %>%
       ggplot(aes(x = Iter, y = ratio, colour = rc)) + geom_point() +
       labs(title = "Ratio of time step size over coefficient of drag against iterations",
            x = "Number of Iterations to convergence",
            y = "timestep size divided by drag coefficient") +
       facet_grid(~ec)
  
```



#Accuracy of converged state

This chunk calculates the full movement of the nodes 

```{r}
1:3 %>% walk(~{
  
  task_id <- .x #this is the compute group to be used
  
  load_file <- "UK_high_voltage"

  source(file.path("/home/jonno/setse_and_network_robustness/HPC_files", "HPC_attack_random.R"), local = TRUE)
  
  return(NULL)
  
} )
```



#Extract the data from the zip files

The attack data produced by the HPC is tarred as a larged collection of files and needs to be extracted before it can be used.

This chunk does that extraction.

```{r}

list.files("/home/jonno/Dropbox/IEEE_Networks/strain") %>% walk(~{
  
  untar_myriad_strain_files("/home/jonno/Dropbox/IEEE_Networks/strain", .x, extraction_directory = file.path(project_folder, "test_strain"))
  
})

tar_path <-"/home/jonno/HPC_jobs"
  
tar_file <- "files_from_job_2059520.30.tgz"

untar_myriad_collapse_summaries(tar_path, tar_file, extraction_directory = file.path(project_folder, "test_collapse"))

list.files("/home/jonno/HPC_jobs") %>% walk(~{
  
  untar_myriad_collapse_summaries("/home/jonno/HPC_jobs", tar_file = .x, extraction_directory = file.path(project_folder, "test_collapse"))
  
})


```



#Load and aggregate data

Once the data has been moved from the HPC and extracted into a usable format the data can be loaded and aggregated into a single file for speedy access

##Attack data

This takes a very long time.
Like half an hour each graph type
```{r}

#compile the data into a single data frame from all attack files about 30 mins
IEEE_118_results <- list.files(path = "/home/jonno/HPC_jobs/IEEE_118_igraph", 
                                        full.names = TRUE, 
                                        recursive = TRUE) %>%
  map_df(~{read_rds(.x) %>%
           mutate(file_path = dirname(.x)) %>%
  arrange(-nodes) %>%
  mutate_at(.vars = 5:8, .funs = first) %>%
  mutate(has_gc = mean_degree_sqrd > 2*mean_degree) %>%
  filter(!has_gc) %>%
  slice(1)
    })


#The previous loop takes a long time so an rds should be saved for speed. takes about 10 mins
saveRDS(IEEE_118_results, file = file.path("/home/jonno/Dropbox/IEEE_Networks", "IEEE_118_attack_results.rds") )

######
##
##IEEE 14
##
######
#compile the data into a single data frame from all attack files
IEEE_results <- list.files(path = "/home/jonno/HPC_jobs/IEEE_14_igraph", 
                                        full.names = TRUE, 
                                        recursive = TRUE) %>%
  map_df(~{read_rds(.x) %>%
           mutate(file_path = dirname(.x)) %>%
  arrange(-nodes) %>%
  mutate_at(.vars = 5:8, .funs = first) %>%
  mutate(has_gc = mean_degree_sqrd > 2*mean_degree) %>%
  filter(!has_gc) %>%
  slice(1)
    })


#The previous loop takes a long time so an rds should be saved for speed
saveRDS(IEEE_results, file = file.path("/home/jonno/Dropbox/IEEE_Networks", "IEEE_14_attack_results.rds") )

```


##Strain data

This is for the rc test data on IEEE118. The data is aggregated and then saved to a file for faster loading and analysis
This data demonstrates that tension is unaffected by R or C and that tension is also the best proxy for robustness
```{r}



(1:9) %>% walk(~{
  print(.x)
  file_name <- paste0("/home/jonno/test_strain/strainrc/strain_2547988.", .x,"/tmpdir/job/2547988.",.x, "/embeddings/IEEE_118_igraph")
  
 Out <- aggreagte_strain_files(file_name) 
 
 
 file_name <- paste0("IEEE_118_strain_summaries_r", unique(Out$r), "_c_", unique(Out$c), ".rds")
 
 saveRDS(Out, file.path( project_folder, "testing_strain_r_c _118", file_name))

 
})


```


```{r}
test <- readRDS(file = file.path(project_folder, "IEEE_14_attack_results.rds") ) %>%
  group_by(file_path) %>%
  summarise_all(mean) %>%
  mutate(mean_alpha = 1/mean_alpha,
         median_alpha = 1/median_alpha) %>%
  select(-median_alpha) %>%
  mutate(carrying_capacity = signif(carrying_capacity),
         smallest = signif(smallest),
         largest = signif(largest),
         fract = signif(fract))
```


#Aggregate and plot IEEE-118 data

The results of this plot show that SETS is less affect by the change in concentration than alpha of load
```{r}

#using the combined data frame aggregate the results by parameter group
IEEE_118_agg_res <- readRDS(file = file.path(project_folder, "IEEE_118_attack_results.rds") ) %>%
  group_by(file_path) %>%
  mutate(auc = sum(1-blackout_size)/179) %>% #the auc is the sum of all blackouts divided by the total edges aka attacks
  summarise_all(mean) %>%
  mutate(mean_alpha = 1/mean_alpha,
         median_alpha = 1/median_alpha) %>%
  select(-median_alpha) %>%
  mutate(carrying_capacity = signif(carrying_capacity),
         smallest = signif(smallest),
         largest = signif(largest),
         fract = signif(fract))


  #function that finds what fraction of the full range the metric is
kappa <- function(value){
  
  (value-min(value))/(max(value) - min(value))
  
}


```

#test all strainRC
```{r}

all_metrics_df <- list.files(file.path( project_folder, "testing_strain_r_c _118"), full.names = T) %>% map_df(~{

 test <- readRDS(.x)#aggreagte_strain_files(file_name)

  #convert to range values
strain_norm_df <-test %>% filter(converged==1) %>%#readRDS(file = file.path("/home/jonno/Dropbox/IEEE_Networks", "strain_df.rds") )%>%
  mutate(#force strain to be relative
    mean_strain = kappa(mean_strain),
    median_strain = kappa(median_strain),
    mean_tension = kappa(mean_tension),
    median_tension = kappa(median_tension),
    energy = kappa(energy)
  )
  

#bind the attack and strain data together
all_metrics_df <- IEEE_118_agg_res %>%
  left_join(strain_norm_df, by = c("carrying_capacity", "smallest", "largest", "fract", "robin_hood_mode")) %>%
  rename(harmonic_alpha = mean_loading) %>%
  filter(!is.na(mean_strain)) %>%
  pivot_longer(., cols = c("harmonic_alpha", 
                           #"median_loading", 
                           "mean_alpha", 
                           "mean_tension", 
                           "mean_strain", 
                          # "median_strain",
                           "mean_tension"#, 
                          # "median_tension", 
                           #"energy"
                          ), 
               names_to = "metric" ) %>%
  mutate(embeddings = case_when(
    grepl("tension|strain", metric) ~ "embeddings",
    TRUE ~"alpha" 
  ))  

})


#plot the relationship between number of attacks and the metric
#choose r and c and fraction. fraction is optional
all_metrics_df %>%
   filter(
       #fract ==1,
       r ==100,
       c ==10000
          ) %>%
  ggplot(aes(x = value, y = attack_round, colour = factor(carrying_capacity), group = metric)) + 
  geom_point() +
  facet_wrap(~embeddings + metric) +
  labs(colour = "Capacity", y = "Attack round", x = "Fraction of total range")+
  geom_smooth(method = "loess",se = FALSE) +
  labs(title = "The relationship between robustness metrics and number of attacks until failure",
          y = "Number of rounds until loss of giant component")


```


#Metric performance
```{r}

#Plot the performance of the metric across different r c values
 multi_metric <- metric_set(rmse, rsq, mae, smape)
 
metric_combos <- expand_grid(metrics = unique(all_metrics_df$metric),
             r = 10^(2:4),
             c = 10^(2:4))
 
  metric_performance <-1:nrow(metric_combos) %>%
    map_df(~{
      
      temp <- all_metrics_df %>%
        filter(
          !is.na(value),
          r == metric_combos$r[.x],
          c == metric_combos$c[.x],
          metric == metric_combos$metrics[.x])
      
      loess_mod <- loess(formula =attack_round~ value, 
                         data = temp)
      
      model_comp <- temp  %>%
        mutate(preds = predict(loess_mod)
        )
      
      multi_metric(data = model_comp, truth = attack_round, estimate = preds) %>% 
        mutate(type = metric_combos$metrics[.x],
               r = temp$r[1],
               c = temp$c[1])
      
    })

metric_performance %>%
#  filter(type != "mean_alpha") %>%
  ggplot(aes(x = type, y = .estimate, fill = type)) + geom_boxplot() + 
  facet_wrap(~.metric, scales = "free_y") + theme(axis.text.x = element_text(angle = 30, hjust = 1))
```

#Find missing

In the case that some of the data was not calculated properly and has not been created. this code chunk can be used to find the missing files for recalculation
```{r}
folder <- "/home/jonno/HPC_jobs/UK_high_voltage"
missing_df<-tibble(files = list.files(folder, pattern = ".tgz")) %>%
  separate(col = files, into = c("drop1", "id", "drop2"), sep = "\\.", remove = F) %>%
  select(files, id) %>%
  full_join(tibble(id = as.character(1:288)), .) %>%
  filter(!complete.cases(.))


```

#What time?
how long did it take to calulate each strain
```{r}

test <- list.files("/home/jonno/test_strain/IEEE_118_igraph", 
                   pattern = "HPC_strain_concentrator_script.R.out_2113018",
                   full.names = TRUE) %>%
  map_chr(~{
    
   file_lines <- readLines(.x)
   
  file_lines[length(file_lines)]
    
  }) %>%str_replace(., "Time difference of ", "") %>%
  str_replace(., " mins", "") %>%
  as.numeric()

test2 <- tibble(time = test)
ggplot(test2, aes(x = time)) + geom_density()

```


#Attack networks
test for attacking all the networks script
```{r}
1:288 %>% walk(~{
  
  task_id <- .x #this is the compute group to be used
  
  load_file <- "IEEE_118_igraph"

  source(file.path("/home/jonno/setse_and_network_robustness", 
                   "HPC_files", 
                   "HPC_files_concentrator",
                   "HPC_attack_concentrator_script.R"), 
         local = TRUE)
  
  return(NULL)
  
} )

```


#Attack UK 10k
This chunk deals with the prep test and load of the 10k attacks against the UK grid
```{r}

1:nrow(288) %>% walk(~{
  
  task_id <- .x #this is the compute group to be used
  
  load_file <- "IEEE_118_igraph"

  source(file.path("/home/jonno/Spring_Embeddings_Paper", "HPC_attack_script.R"), local = TRUE)
  
  return(NULL)
  
} )

microbenchmark({  task_id <- 1 #this is the compute group to be used
  
  load_file <- "UK_high_voltage"

  source(file.path("/home/jonno/setse_and_network_robustness", "HPC_files","HPC_attack_random.R"), local = TRUE)},
  times = 30)


test <- list.files("/home/jonno/HPC_jobs/tenkattack/UK_high_voltage", 
                   pattern = ".rds",
                   full.names = TRUE,
                   recursive = T) %>%
  map_df(~{
    Out <- .x %>% readRDS()  %>%  
      arrange(-nodes) %>%
      mutate(has_gc = mean_degree_sqrd > 2*mean_degree,
             auc = 1-mean(blackout_size),
             simulation_id = str_remove(basename(.x), "simulation_id_") %>% str_remove(., ".rds") %>% as.integer()) %>%
      filter(!has_gc) %>%
      slice(1) 
    
    return(Out)
    
  })

```

#Other network data

Extracts all the tarred data from the HPC generated files
```{r}
list.files("/home/jonno/HPC_jobs/attack/IEEE_14_igraph", pattern = ".tgz", full.names = F) %>% 
  walk(~{
  untar(tarfile = file.path("/home/jonno/HPC_jobs/attack/IEEE_14_igraph", .x), 
        exdir = extraction_directory,#, 
        extras = "--strip-components 4"  #take only the useful bits of the zip file
      )
  
})

list.files("/home/jonno/HPC_jobs/attack/IEEE_30_igraph", pattern = ".tgz", full.names = F) %>% 
  walk(~{
  untar(tarfile = file.path("/home/jonno/HPC_jobs/attack/IEEE_30_igraph", .x), 
        exdir = extraction_directory,#, 
        extras = "--strip-components 4"  #take only the useful bits of the zip file
      )
  
})

list.files("/home/jonno/HPC_jobs/attack/IEEE_57_igraph", pattern = ".tgz", full.names = F) %>% 
  walk(~{
  untar(tarfile = file.path("/home/jonno/HPC_jobs/attack/IEEE_57_igraph", .x), 
        exdir = extraction_directory,#, 
        extras = "--strip-components 4"  #take only the useful bits of the zip file
      )
  
})





list.files("/home/jonno/HPC_jobs/attack/IEEE_300_igraph", pattern = ".tgz", full.names = F) %>% 
  walk(~{
  untar(tarfile = file.path("/home/jonno/HPC_jobs/attack/IEEE_300_igraph", .x), 
        exdir = extraction_directory,#, 
        extras = "--strip-components 4"  #take only the useful bits of the zip file
      )
  
})


#The 10k attack data

list.files("/home/jonno/HPC_jobs/tenkattack/UK_high_voltage", pattern = ".tgz", full.names = F) %>% 
  walk(~{
  untar(tarfile = file.path("/home/jonno/HPC_jobs/tenkattack/UK_high_voltage", .x), 
        exdir = "/home/jonno/HPC_jobs/UK_high_voltage",#, 
        extras = "--strip-components 4"  #take only the useful bits of the zip file
      )
  
})

```



#Find target and minimise

The below chunk performs and auto setse convergence and plots the results. these should be incorporated at some point to show how performance differs when compared to the other methods
```{r}

system.time(auto_sets_df <- auto_SETSe(g, 
           force ="net_generation", 
           flow = "power_flow", 
           distance = "distance", 
           capacity = "edge_capacity",
           edge_name = "edge_name",
           tstep = 0.01, 
           mass = 1, 
           max_iter = 100000, 
           tol = 2e-3,
           sparse = FALSE,
           hyper_iters = 100,
           sample = 100))

auto_sets_df$memory_df %>%
  filter(is.finite(res_stat)) %>%
  ggplot(aes(x = log10(common_drag_iter), y = log10(res_stat))) + geom_point()

auto_sets_df$memory_df %>%
  filter(is.finite(res_stat)) %>%
  ggplot(aes(x = iteration, y = log_ratio)) + geom_point()


#This combined with a plot that marked out the full valley would be really good
auto_sets_df$memory_df %>%
  filter(is.finite(res_stat),
         # log10(res_stat)<0
         ) %>%
  ggplot(aes(y = log10(res_stat), x = (common_drag_iter))) + geom_path()+
geom_point(colour = "blue")

test <-auto_sets_df$memory_df

dynamics <- auto_sets_df$network_dynamics


dynamics %>%
  ggplot(aes(x = t, y = log10(static_force))) + geom_point()

```

#Get the auto convergences for the different networks
IEEE-300 and uk high voltage is done on the HPC as they are significantly slower taking approx 90 seconds per network
```{r}
 
for(i in (c(paste0("IEEE_",c(14, 30, 57,118, 300) ,"_igraph"), "UK_high_voltage"))){
  
  task_id <-  1#this is the compute group to be used
  
  load_file <- i 
  
  source(file.path("/home/jonno/setse_and_network_robustness/HPC_files/HPC_files_concentrator", "HPC_strain_autoconverge_script.R"), 
         local = TRUE)
}
  


list.files("/home/jonno/test_strain/UK_high_voltage", pattern = ".tgz", full.names = T) %>% 
  walk(~{
  untar(tarfile =.x, 
        exdir = "/home/jonno/Dropbox/IEEE_Networks/embeddings/UK_high_voltage",#, 
        extras = "--strip-components 4"  #take only the useful bits of the zip file
      )
  
})


test <- embeddings_data$memory_df %>%
  mutate(diff = 1-res_stat/lag(res_stat),
         diff2 = abs(diff)>0.01)


  task_id <-1 #this is the compute group to be used
  
  load_file <- "UK_high_voltage"
  
  source(file.path("/home/jonno/setse_and_network_robustness/HPC_files/HPC_files_concentrator", "HPC_strain_big_autoconverge_script.R"), 
         local = TRUE)

```

#PL strain
calculate the strain for the proportionally loaded networks
```{r}

for(i in c(paste0("IEEE_",c(14, 30, 57,118, 300) ,"_igraph"), "UK_high_voltage")){
  
  task_id <-  1#this is the compute group to be used
  
  load_file <- i
  
  source(file.path("/home/jonno/setse_and_network_robustness/HPC_files/HPC_PL", 
                   "HPC_pl_strain.R"), 
         local = TRUE)
}

```

```{r}
list.files("/home/jonno/HPC_jobs", pattern = "PL", full.names = T) %>% walk(~{
  
  list.files(.x, pattern = ".tgz", full.names = T) %>% 
  walk(~{
  untar(tarfile =.x, 
        exdir = "/home/jonno/Dropbox/IEEE_Networks/PL_attacks",#, 
        extras = "--strip-components 4"  #take only the useful bits of the zip file
      )
  
})
  
})


list.files("/home/jonno/test_strain/IEEE_118_igraph_strain_rc_spike_target2/IEEE_118_igraph_strain_rc_spike_target2_raw", pattern = ".tgz", full.names = T) %>% 
  walk(~{
  untar(tarfile =.x, 
        exdir = "/home/jonno/test_strain/IEEE_118_igraph_strain_rc_spike_target2",#, 
        extras = "--strip-components 4"  #take only the useful bits of the zip file
      )})

list.files("/home/jonno/test_strain/strain_sqrt_k_raw", full.names = T) %>% walk(~{
  print(.x)
  graph_name <- basename(.x)
  list.files(.x, pattern = ".tgz", full.names = T) %>% 
  walk(~{
  untar(tarfile =.x, 
        exdir = file.path("/home/jonno/test_strain/strain_sqrt_k", graph_name),#, 
        extras = "--strip-components 4"  #take only the useful bits of the zip file
      )
  
})
  
})

```

#Timing

This chunk extracts timings, which can be used for various things
```{r}

folder <-"/home/jonno/HPC_jobs/UK_high_voltage"# "/home/jonno/test_strain/UK_high_voltage"

test <-list.files(folder, pattern = ".out", full.names = T) %>%
  map_df(~{
    
    test <-read_lines( .x )
    
    tibble(time = parse_number(test[length(test)], "[0-9]+")[[1]],
           unit = str_extract(test[length(test)], '\\w+$'))
    
  }) %>%
  mutate(total_mins = ifelse(unit == "hours", time*60, time),
         total_hours = ifelse(unit == "hours", time, time/60))


test %>%
  ggplot(aes(x = total_hours)) + geom_density()

```

```{r}
file_vect <-list.files("/home/jonno/Dropbox/IEEE_Networks/embeddings/UK_high_voltage", full.names = T)

test2 <-file_vect %>%
      map_df(~{
        file_name = .x
        temp <- readRDS(file_name)
        temp_edge<- temp$edge_embeddings
        
        parts <- str_split(basename(file_name), pattern = "_", simplify = T)
        
        temp_edge %>%
          summarise(mean_loading =mean(line_load, na.rm = T),
                    median_loading = median(line_load, na.rm = T),
                    mean_alpha = mean(1/line_load, na.rm = T),
                    median_alpha = median(1/line_load, na.rm = T),
                    mean_strain = mean(strain, na.rm = T),
                    median_strain = median(strain, na.rm = T),
                    mean_tension = mean(tension, na.rm = T),
                    median_tension = median(tension, na.rm = T)
          ) %>%
          mutate(
         #   static_force = sum(abs(temp$node_embeddings$static_force)),
            fract = parts[2],
            carrying_capacity = parts[4],
            largest = parts[6],
            smallest = parts[8],
            robin_hood_mode = str_remove(parts[11], pattern = ".rds"))
        
      }) %>% mutate(graph = basename(.x))


```


#Alt Area & E
```{r}
new_k <-function(alpha_fract = 1, power_fract = 1, r = 100, c = 100){
  
  r^2*(alpha_fract+power_fract) + r*c*(alpha_fract+power_fract) + c^2
  
}

test_combos <- expand.grid(r = 10^(1:5), c = 10^(1:5)) %>% 
  as_tibble() %>%
  mutate(k = new_k(r = r, c = c),
         sqrtk =  new_k(r = sqrt(r), c = sqrt(c)),
         log10k  = log10(k),
         log10sqrtk = log10(sqrtk))



test_combos <- expand.grid(alpha_fract = seq(0, 1, 0.01), power_fract = seq(0, 1, 0.01)) %>% 
  as_tibble() %>%
  mutate(k = new_k(alpha_fract, power_fract, r = 1000, c = 1000),
    k_sqrt = sqrt(new_k(alpha_fract, power_fract, r = 1000, c = 1000)),
         sqrt_k =  new_k(alpha_fract, power_fract, r = sqrt(1000), c = sqrt(1000)),
        k_sqrt2 = kappa(k_sqrt),
         sqrt_k2 = kappa(sqrt_k))


test_combos %>%
  pivot_longer(., cols = k_sqrt2:sqrt_k2) %>%
  ggplot(aes(x = alpha_fract, y = power_fract, fill = value)) + 
  geom_raster() +
  scale_fill_viridis_c()+
  facet_wrap(~name)
##Squareing the result not the imput means that the most high flow edge is stiffer than if the input is squared. When the output is squared you get the hypotenuse which is greater than half when r=c
test_combos %>%
  pivot_longer(., cols = k_sqrt2:sqrt_k2) %>%
  filter(power_fract==0) %>%
 # filter(power_fract==alpha_fract) %>%
  ggplot(aes(x = alpha_fract, y = value, colour = name)) + 
  geom_line()

```


```{r}
list.files("/home/jonno/test_strain/IEEE_118_igraph_strain_rc_spike_target/IEEE_118_igraph_strain_rc_spike_target_raw", 
           pattern = ".tgz", full.names = T) %>% 
  walk(~{
  untar(tarfile =.x, 
        exdir = "/home/jonno/test_strain/IEEE_118_igraph_strain_rc_spike_target/IEEE_118_igraph_strain_rc_spike_target",#, 
        extras = "--strip-components 4"  #take only the useful bits of the zip file
      )})

```

##load alt
```{r}

test <- process_rc_comparisons(save_file_path = "/home/jonno/test_strain/IEEE_118_igraph_strain_rc_alt/rc_alt_metrics_df.rds", 
                                          load_file_path = "/home/jonno/test_strain/IEEE_118_igraph_strain_rc_alt/IEEE_118_igraph/IEEE_118_igraph", 
                                          aggregated_attack_df =  all_graph_agg %>% filter(graph == "IEEE_118_igraph") )

test <- process_rc_comparisons(save_file_path = "/home/jonno/test_strain/IEEE_118_igraph_strain_rc_spike_target/rc_alt_metrics_df.rds", 
                                          load_file_path = "/home/jonno/test_strain/IEEE_118_igraph_strain_rc_spike_target/IEEE_118_igraph_strain_rc_spike_target/IEEE_118_igraph", 
                                          aggregated_attack_df =  all_graph_agg %>% filter(graph == "IEEE_118_igraph") )



test <- process_rc_comparisons(save_file_path = "/home/jonno/test_strain/IEEE_118_igraph_strain_rc_spike_target2/rc_alt_metrics_df.rds", 
                                          load_file_path = "/home/jonno/test_strain/IEEE_118_igraph_strain_rc_spike_target2/IEEE_118_igraph", 
                                          aggregated_attack_df =  all_graph_agg %>% filter(graph == "IEEE_118_igraph") )

test   %>% 
  filter(
    metric !="alpha",
    metric !="loading",
    static_force<0.002,
  average_type =="mean",
       r ==100,
       c ==1000
          ) %>%
  mutate(metric = str_replace(metric, "_", " ")) %>%
  ggplot(aes(x = value, y = attack_round, colour = as.factor(robin_hood_mode), group = metric)) + 
  geom_point() +
  facet_wrap(~metric, scales = "free_x") +
  labs(colour = "Capacity", y = "Attack round", x = "Fraction of total range")+
  geom_smooth(method = "loess",se = FALSE) +
  labs(title = "The relationship between robustness metrics and number of attacks until failure",
          y = "Number of rounds until loss of giant component")

```

##model alt
```{r}
metric_combos <- test %>%
  filter(metric %in% c("strain", "tension")) %>%
  distinct(., average_type, metric, r,c) %>%
  filter(metric !="alpha")

  metric_performance_test <-1:nrow(metric_combos) %>%
    map_df(~{
      print(.x)
      temp <- test %>%
        filter(
          static_force<0.002,
          !is.na(value),
          r == metric_combos$r[.x],
          c == metric_combos$c[.x],
          metric == metric_combos$metric[.x],
          average_type == metric_combos$average_type[.x]
          )
      
      loess_mod <- loess(formula =attack_round~ value, 
                         data = temp)
      
      model_comp <- temp  %>%
        mutate(preds = predict(loess_mod)
        )
      
      multi_metric(data = model_comp, truth = attack_round, estimate = preds) %>% 
        mutate(metric = metric_combos$metric[.x],
               average_type = metric_combos$average_type[.x],
               r = temp$r[1],
               c = temp$c[1])
      
    })
  
  
  test <- metric_performance_test %>%
  filter(average_type=="mean",
         metric == "strain") %>%
  group_by(.metric) %>%
  mutate(perc = ifelse(.metric =="rsq",rank(signif(-.estimate, 3)), rank(signif(.estimate, 3))),
         perc2 = .estimate/min(.estimate),
         perc2 = ifelse(perc2>2, 2, perc2)-1
         )
  
  
  test %>% ggplot(aes(x = factor(r), y = factor(c, levels =rev(10^(1:5))), fill= perc2, )) + geom_raster() +
  facet_wrap(~.metric) +
  geom_text(aes(label = signif(.estimate, 3))) +
    scale_fill_viridis_c(limits = c(-1, 1)) +
    labs(title = "Model performance mean tension across multiple metrics by r and c", 
       x = "range of k", 
       y = "minimum k value",
       fill = "relative Error")
  
  
  metric_performance_test  %>%
    filter(average_type == "mean",
           metric != "energy",
           r == 100,
           c == 10000) %>%
  group_by(.metric) %>%
  mutate(perc = ifelse(.metric =="rsq",rank(signif(-.estimate, 3)), rank(signif(.estimate, 3))),
         perc2 = 1-ifelse(.metric =="rsq", (.estimate-max(.estimate))/max(.estimate), (.estimate-max(.estimate))/max(.estimate))) %>%
    ggplot(aes(x = metric, y = .estimate)) + geom_col()+
    facet_wrap(~.metric, scales = "free")
  
```

##Alternative kappa
measures strain and tension for each line then averages

rather surprisingly the strain/tension on an individual line can exceed the ma/minima of 1 and Inf values. This shows that force is concentrated on different parts of the network

```{r}
folder_name <-  "/home/jonno/Dropbox/IEEE_Networks/embeddings/IEEE_118_igraph" 
graph_name <- basename(folder_name)
PL_1 <- read_rds(file.path("/home/jonno/Dropbox/IEEE_Networks/embeddings/PL", graph_name, "ec_1.rds"))$edge_embeddings
PL_inf <- read_rds(file.path("/home/jonno/Dropbox/IEEE_Networks/embeddings/PL", graph_name, "ec_Inf.rds"))$edge_embeddings

summ_mini <-function(x) {x %>%
          summarise(
            mean_loading =mean(line_load, na.rm = T),
            median_loading = median(line_load, na.rm = T),
            mean_alpha = mean(1/line_load, na.rm = T),
            median_alpha = median(1/line_load, na.rm = T),
            mean_strain = mean(strain, na.rm = T),
            median_strain = median(strain, na.rm = T),
            mean_tension = mean(tension, na.rm = T),
            median_tension = median(tension, na.rm = T)
          )}

PL_1_summ <- PL_1 %>% summ_mini()
PL_inf_summ <- PL_inf %>% summ_mini()

range_df <- left_join(PL_1 %>% select(edge_name, pl_1_tension = tension, pl_1_strain = strain),PL_inf %>% select(edge_name, pl_inf_tension = tension, pl_inf_strain = strain), by = "edge_name")

    Out <- list.files(folder_name, full.names = T) %>%
      map_df(~{
        file_name = .x
        temp <- readRDS(file_name)
        temp_edge <- temp$edge_embeddings
        
        parts <- str_split(basename(file_name), pattern = "_", simplify = T)
        
        spec <- temp_edge %>% left_join(range_df, by = "edge_name") %>%
          mutate(tension2 = (tension- pl_1_tension)/(pl_inf_tension - pl_1_tension),
                 strain2 = (strain- pl_1_strain)/(pl_inf_strain - pl_1_strain))
        
         temp_edge %>% summ_mini() %>%{ (.- PL_inf_summ)/(PL_1_summ-PL_inf_summ)} %>%
          mutate(
            mean_spectension = mean(spec$tension2),
            median_spectension = median(spec$tension2),
            mean_specstrain = mean(spec$strain2),
            median_specstrain = median(spec$strain2),
            static_force = sum(abs(temp$node_embeddings$static_force)),
            fract = parts[2],
            carrying_capacity = parts[4],
            largest = parts[6],
            smallest = parts[8],
            robin_hood_mode = str_remove(parts[11], pattern = ".rds"))
        
      }) %>% mutate(graph = basename(graph_name))
    
    return(Out)

  #  test <- temp_edge %>% summ_mini()
    
test <- temp_edge %>% mutate(mean_spectension = (tension -PL_inf$tension)/(PL_1$tension-PL_inf$tension))


mean(test$tension2)
median(test$strain2)

test %>%
  ggplot(aes(x = tension)) + geom_density()

    .x <- "/home/jonno/Dropbox/IEEE_Networks/embeddings/IEEE_118_igraph/fract_0.5_ec_1.025_largest_0.5_smallest_0.1_robin_hood_TRUE.rds"  
    
    
all_SETSe_emebeddings <- left_join(all_graph_agg %>% 
                    select(-mean_alpha, -mean_loading,-median_loading) %>%
                    mutate(
    carrying_capacity = as.character(carrying_capacity),
    largest = as.character(largest),
    smallest = as.character(smallest),
    fract = as.character(fract),
    robin_hood_mode = as.character(robin_hood_mode),

  ),
                  Out) %>%
  mutate_at(1:4, list(as.numeric)) %>%
  group_by(graph) %>%
  pivot_longer(.,cols = mean_loading:median_specstrain, names_to = "metric") %>%
  separate(., col ="metric", into = c("average_type", "metric"), sep ="_") %>%
  ungroup
```


#excess generation

This checks the amount of excess generation each network has.
It may be interesting to controll the amount of excess generation and see what this does to error spikes


```{r}
list.files("/home/jonno/Dropbox/IEEE_Networks/power_grid_graphs", pattern = ".rds", full.names = T) %>%
  map_df(~{
    read_rds(.x) %>%
      as_data_frame(., what = "vertices") %>%
      summarise(demand = sum(demand),
                 generation = sum(generation)) %>%
    mutate(ratio = generation/demand,
           name = basename(.x) %>% str_remove(., ".rds"))
    
  })


g_path <- "/home/jonno/Dropbox/IEEE_Networks/power_grid_graphs/IEEE_118_igraph.rds"

temp_g <- read_rds(g_path)

tension_weighted_edge <- function(temp_g){

#get the total power generated in each component
temp_sum <- as_data_frame(temp_g, what = "vertices")  %>% 
      summarise(demand_fract = sum(demand),
                generation_fract = sum(generation),
                net_generation_fract = sum(ifelse(net_generation>0, net_generation, 0)))

#create balanced blocks for each component
test <- temp_g %>% #as_data_frame(., what = "vertices")
    create_balanced_blocks(., 
                         force = "net_generation", 
                         flow = "power_flow")


#the fraction of each metric by edge.
Out <- 1:length(test) %>%
  map_df(~{
    temp <- as_data_frame(test[[.x]], what = "both") 
    
    node_stats <- temp$vertices %>% 
      summarise(demand_fract = sum(demand),
                generation_fract = sum(generation),
                net_generation_fract = sum(ifelse(net_generation>0, net_generation, 0))) %>%
      mutate(block = .x)
    temp$edges%>%
      mutate(block = .x) %>%
      left_join(node_stats, by  = "block")
    }) %>%
  mutate(demand_fract = demand_fract/temp_sum$demand_fract,
         generation_fract = generation_fract/temp_sum$generation_fract,
         net_generation_fract = net_generation_fract/temp_sum$net_generation_fract) %>%
  select(edge_name, block:net_generation_fract)

return(Out)

}



temp_g <- read_rds(file.path(power_grid_graphs_path, paste0(basename(dirname(.x)), ".rds")))
test <- tension_weighted_edge(temp_g)

```

