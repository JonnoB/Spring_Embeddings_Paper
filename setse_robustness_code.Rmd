---
title: "Untitled"
author: "Jonathan Bourne"
date: "22 March 2019"
output: html_document
editor_options: 
  chunk_output_type: console
---

https://github.com/schochastics/graphlayouts

https://github.com/hackl/tikz-network


some IEEE datasets
https://icseg.iti.illinois.edu/power-cases/

annpotate points with rectangles
https://ggforce.data-imaginist.com/reference/geom_mark_rect.html

#Set up
```{r Setup}

packages <- c("tidyverse", "igraph","readr","readxl", "broom", "stringr", "xtable", "rlang", "animation", "caret", "sf", "rgdal", "sf", "gstat", "automap", "rayshader", "latex2exp", "yardstick", "minpack.lm", "gganimate", "tmaptools", "rgeos", "raster", "tigris")

new.packages <- packages[!(packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)

select <- dplyr::select
arrange <- dplyr::arrange
sapply(packages, library, character.only = TRUE)

library(PowerGridNetworking)
library(NetworkSpringEmbedding)

#Set up file system to read the correct folders this switches between aws and windows mode

basewd <- "/home/jonno/Dropbox/Jonathan_Bourne_Phd_Folder"
CodeFolder <- "/home/jonno/setse_and_network_robustness"
datafile <- "/home/jonno/Dropbox/Jonathan_Bourne_Phd_Folder/ETYSAppendixB"
LatexFolder <- "/home/jonno/Dropbox/Apps/ShareLaTeX/Sets Paper 2" 
FiguresFolder <- file.path(LatexFolder, "Figures")
TablesFolder <- file.path(LatexFolder, "Tables")
MatricesFolder <- file.path(LatexFolder, "Matrices")
Tariff <- file.path(basewd,"Tariff and Transport")
PLwd <- "/media/jonno/Seagate Expansion Drive/System_Dynamics"
Deletion_Order_Folder <-  file.path("/home/jonno/Dropbox/AWS_Simulation_Files") #Only one of the deletion order folders is needed. Either Nodes or Edges
project_folder <- "/home/jonno/Dropbox/IEEE_Networks" #"/media/jonno/Seagate Expansion Drive/IEEE_Networks"
embeddings_path <- file.path(project_folder, "embeddings")
power_grid_graphs_path <- file.path(project_folder, "power_grid_graphs") 

#Load some other useful functions
list.files("/home/jonno/Useful_PhD__R_Functions", pattern = ".R", full.names = T) %>%
  walk(~source(.x))

VertexMetaData2 <- VertexMetaData %>%
  mutate(NodeType = case_when(
    BalencedPower>0 ~"Generator",
    BalencedPower< 0~"Demand",
    TRUE ~ "Transfer"
  ),
  NodeType2 = case_when(
    Demand>0 & Generation>0 ~"Hybrid",
    TRUE ~ NodeType
  )) %>% select(Name, NodeType, NodeType2, BalencedPower)



#Is this function here neccessary? or is it in some folder that gets it all laoded?
  #function that finds what fraction of the full range the metric is
kappa <- function(value){
  
  (value-min(value))/(max(value) - min(value))
  
}


```


#Psychadelic beard/boat

This plots the strain values of a 4 node three edge graph with a constant EC and varying alpha. It shows that strain is more expressive than either alpha, ec or a combination of the two

The code giveing the animation that shows convergence has been lost. The animation is pretty helpful so it is a good idea to do it again.
```{r}

#The function that calculate the force from the angle
ForceV_from_angle <- function(target_angle, k, d){
  #allows us to tune an angle to get a specific force. alternatively we can tune k and d!
  tibble(H = sqrt(d^2 * (1 + tan(target_angle)^2)),
         ForceT = k*(H-d), 
         ForceV = ForceT*sin(target_angle)) %>%
    pull(ForceV)
  
}

#Get all the possible combinations of each edge excluding height data
fixed_mean_alpha  <- 20:80 %>%
  map_df(~{
     BranchEC <-100-.x -20
    
     tibble(A = .x,
           B =10 + BranchEC*(0:100)/100,
           C = 10 +  BranchEC*(100:0)/100,)
    
  } ) %>%
  mutate(groupID = 1:n()) %>%
  gather(key = edge, value = capacity, - groupID) %>%
  left_join(tibble(edge = c("A", "B", "C"), 
                   flow = c(20,10,10)), #edge flow is always postive! 
            by = "edge") %>%
  mutate(alpha = capacity/abs(flow)) %>% #calculate alpha from the flow and edge capacity
  group_by(groupID) %>%
  mutate(mean_alpha = mean(alpha),
         mean_load = mean(1/alpha), #The harmonic mean of alpha aka mean load
         flow_fract = abs(flow)/sum(ifelse(flow>0,flow,0)),
         excess_cap = sum(alpha*flow_fract)/3) %>%
  group_by(mean_alpha) %>%
  mutate(counts = n(),
         k = 100*(10-1)*(1-1/alpha)+100,
         rank = rank(excess_cap, ties.method = "random")) %>% 
  ungroup 

#Minimise the data down to only the usefully distinct data
Edge_combos <- fixed_mean_alpha  %>%
  distinct(alpha, flow, .keep_all = TRUE) %>%
  mutate(groupID2 = 1:n())

#Calculate heights for each node pair combination
Edge_combos_delta_z <- Edge_combos$groupID2  %>% 
  map_df(~{  
    if((.x/100)%%1 == 0){ (print(.x))} #print every 100
    
    current_settings <- Edge_combos   %>%
      filter(groupID2 == .x)
    
    solution_angle <- nlsLM(Force ~ ForceV_from_angle(target_angle, k = k, d = 1), 
                            start = c(target_angle = pi/4), 
                            data = list(Force = current_settings$flow, k = current_settings$k), 
                            upper = pi/2)
    
    
    Out <- current_settings %>%
      mutate( theta_rads = coef(solution_angle)[1],
              theta_degs = theta_rads*360/(2*pi),
              delta_z = tan(theta_rads),
              delta_h = sqrt(delta_z^2 + 1)-1,
              strain = delta_h # this is because the distance is 1 and strain = (H-d)/d and H = delta_h+d
      ) %>%
      select(groupID, theta_rads, theta_degs, delta_z, flow, alpha, k, delta_h, strain)
  })  

#calculate the ratio of excess capacity split between B and C then join with the alpha value by group
#using capcity or 1/alpha gives the same value 
toy_theta_temp <-  fixed_mean_alpha %>%
  select(groupID, edge, alpha, counts) %>%
  spread(key = edge, value = alpha) %>%
  mutate(
   B= 1/B, #It appears to make no difference if alpha or load level is used
    C = 1/C,
    ratio = (B)/(C+B)) %>%
  left_join(fixed_mean_alpha %>%
  select(groupID, mean_alpha, mean_load) %>%
    distinct) %>%
    select(-A, -B, -C)

#get combine the previous df's together to get the strain across the system for all combinations
toy_height_data <- fixed_mean_alpha %>%
select(groupID, edge, flow, alpha) %>%
  #add in the height data
  left_join(Edge_combos_delta_z %>% select(-groupID))  %>%
  select(groupID, edge, strain) %>%
  #Use spread to keep the delta values for each edge
  spread(key = edge, value = strain) %>%
  mutate(mean_strain = (A+B+C)/3) %>%
  left_join(toy_theta_temp, by = "groupID")


  toy_height_data %>%
    # some of the mean_alpha values are seperating on machine tolerance or something
        mutate(mean_alpha = signif(mean_alpha,5)) %>% 
    #filter(mean_alpha <=2.5) %>%
    ggplot(aes(x = ratio, y = mean_strain, colour = mean_alpha, group = mean_alpha)) + 
    geom_line(size = 1) +
    scale_colour_viridis_c() +
    labs(title ="Strain and System Tolerance in terms of capacity fraction in edge B", 
         y = "System Strain", 
         x= latex2exp::TeX("$\\frac{\\tau_{B}}{\\tau_{B}+\\tau_{C}}$"),
         colour = "System \ntolerance") #latex2exp::TeX(paste("system", "$\\alpha$"))
  ggsave(file.path(FiguresFolder, "Constant_excess_capacity.pdf"))

"Relationship between alpha, excess capacity and theta"

latex2exp::TeX(paste("The relationship between strain and ", 
                                     "$\\alpha \\,$", 
                                     " in terms of capacity fraction in edge B" ))


#This is the mean load.... What the hell is going on?
  toy_height_data %>%
    mutate(mean_load = signif(mean_load,3)) %>% 
    ggplot(aes(x = ratio, y = mean_strain, colour = mean_load)) + 
    geom_point() +
    scale_colour_viridis_c()
  
  
  #The relationship between load and strain is wierd and looks similar to entropy
    toy_height_data %>%
   mutate(mean_load = signif(mean_load,5)) %>% 
    ggplot(aes(colour = mean_alpha, y = mean_strain, x = mean_load, group = mean_alpha)) + 
    geom_line(size = 1)+
    scale_colour_viridis_c() +
      scale_x_reverse()

toy_height_data %>%
  filter((mean_strain == min(mean_strain)))

fixed_mean_alpha %>%
  filter(groupID==2879)


test <- toy_height_data %>%
  group_by(alpha = round(mean_alpha,5)) %>%
  summarise(min_strain = min(mean_strain),
            max_strain = max(mean_strain)) %>%
  mutate(strain_diff = (min_strain-max_strain)/min_strain,
         strain_rat = max_strain/min_strain)

test %>%
ggplot(aes(x = alpha, y = strain_rat)) +
  geom_line()
```

##Entropic degree
```{r}

entropy_data <- fixed_mean_alpha %>%
  group_by(groupID) %>%
  mutate(p_capacity = capacity/sum(capacity), #fraction of total capacity
         p_alpha = alpha/sum(alpha), #fraction of total alpha
         entrop_capacity = -p_capacity*log(p_capacity), #
         entrop_alpha = -p_alpha*log(p_alpha)) %>%
  summarise(capacity = sum(entrop_capacity),
            alpha = sum(entrop_alpha)) %>%
  #normalise the entropy relative to the highest value
  mutate(capacity = capacity/max(capacity), 
         alpha = alpha/max(alpha))

toy_height_data %>%
  select(groupID, mean_strain, mean_alpha) %>%
  left_join(entropy_data) %>%
  gather(key = type, value = div, -mean_strain, - mean_alpha,-groupID ) %>%
    mutate(mean_alpha = signif(mean_alpha,5)) %>%  # some of the mean_alpha values are seperating on machine tolerance or something
  filter(type =="capacity") %>%
  ggplot(aes(x = div, y = mean_strain, colour = mean_alpha, group = mean_alpha)) + 
  geom_line(size = 1) +
  scale_colour_viridis_c() +
  facet_grid(~type) +
  labs(title = "The relationship between strain, system tolerance and entropy", 
       x = "Normalised entropy", 
       y ="system strain", 
       colour =  "Sytem tolerance")
ggsave(file.path(FiguresFolder, "entropy_theta.pdf"))



test <- toy_height_data %>%
  select(groupID, mean_strain, mean_alpha) %>%
  left_join(entropy_data)

rm(entropy_data)
```


#get network statistics

IEEE-118 and IEEE-300 have substantially more negative assortativity than the other networks, however the assortativity is still quite close to 0. Also we see that IEEE-118, IEEE-300 and the UK high voltage network have much larger mean distances between nodes than the other networks, htey also have the smallesting clustering coefficient.

The question is do the spikes that appear on 118 and 300 also appear on the UK high voltage grid? If they do then the spikes may be associated with the clustering or the distance, if not then the spikes may associated with the assortivity.

This could then be tested by creating networks on an assortivity/clustering distance scale and trying to re-create the spikes. This would then help understand which metric would be most appropriate as a proxy for robustness
```{r}

test <- list.files("/home/jonno/Dropbox/IEEE_Networks/power_grid_graphs", pattern = ".rds", full.names = T) %>%
  map_df(~{
    readRDS(.x) %>%
    NetworkStats() %>%
      filter(Metric != "Betweenness") %>%
      mutate(graph = basename(.x),
             Betweenness = mean(betweenness(readRDS(.x), normalized = T))
             )
    
    
  }) %>%
  filter(Metric != "Components") %>%
  pivot_wider(names_from = "Metric", values_from = "value") %>%
  arrange(Nodes) %>%
  mutate(Betweenness = round(Betweenness, 2),
         Degree = round(Degree, 2),
         Assortativity = round(Assortativity, 2),
         Clustering = round(Clustering, 2),
         Distance = round(Distance, 2))

test <- list.files("/home/jonno/Dropbox/IEEE_Networks/power_grid_graphs", pattern = ".rds", full.names = T) %>%
  map_df(~{
    readRDS(.x) %>%  degree() %>% tibble(degree =.) %>%
      group_by(degree) %>%
      summarise(counts = n()) %>%
      mutate(graph = basename(.x)%>% gsub(".rds", "", .),
             perc = counts/sum(counts))
    
    
  }) 


test %>%
  ggplot(aes(x = degree, y = perc, fill = graph)) + geom_col() +
  facet_wrap(~graph)

test %>%
  ggplot(aes(x = Assortativity, y = Clustering, colour = graph)) + geom_point()

```


#Load all collapse data

```{r}
all_graph_agg <- list.files("/home/jonno/Dropbox/IEEE_Networks/attacks", full.names = T, recursive = T) %>%
  map_df(~{
    
    file_path <-.x
    read_rds(file_path) 
  }) %>% 
  group_by(carrying_capacity, smallest, largest, fract, robin_hood_mode, graph) %>%
  summarise_all(mean) %>%
  ungroup %>%
  mutate(mean_alpha = 1/mean_alpha,
         median_alpha = 1/median_alpha) %>%
  select(-median_alpha) %>%
  mutate(carrying_capacity = signif(carrying_capacity),
         smallest = signif(smallest),
         largest = signif(largest),
         fract = signif(fract))

PL_SETSe_emebeddings <- process_all_pl_setse_emebeddings( strain_folders = file.path(embeddings_path, "PL"),
                                                          attack_folders = "/home/jonno/Dropbox/IEEE_Networks/PL_attacks")



test_raw <- list.files("/home/jonno/Dropbox/IEEE_Networks/attacks", full.names = T, recursive = T) %>%
  map_df(~{
    
    file_path <-.x
    read_rds(file_path) 
  }) 

 test <- test_raw %>% filter(graph == "IEEE_118_igraph")

test2 <- test %>%
  select(attack_round, blackout_size, edges, carrying_capacity:graph) %>%
   group_by(carrying_capacity, smallest, largest, fract, robin_hood_mode, graph) %>%
  summarise_all(list(mean = mean, sd = sd))


combos <-test %>%
 select(carrying_capacity, smallest, largest, fract, robin_hood_mode) %>%
distinct() %>%
  mutate(seed = 1:n())



test_res <- (1:nrow(combos)) %>%
  map_df(~{
    
    print(.x)
    test_118 <- test %>%
  filter( carrying_capacity ==combos$carrying_capacity[.x],
         smallest == combos$smallest[.x],
         largest == combos$largest[.x],
         fract == combos$fract[.x],
         robin_hood_mode == combos$robin_hood_mode[.x]) %>%
      {.[,1:4]}

  set.seed(.x)
    sample_rows <-sample(1:100, 100*1000 ,replace = TRUE)
  Out <- data.frame(attack_round = (test_118$attack_round[sample_rows]),
           generation = (test_118$generation[sample_rows]),
           blackout_size = (test_118$blackout_size[sample_rows]),
           nodes = (test_118$nodes[sample_rows])) %>%
  mutate(id = rep(1:100, length.out = 100*1000)) %>%
    group_by(id) %>%
      summarise_all(mean) %>%
    mutate(graph = "IEEE_118_igraph",
         carrying_capacity =combos$carrying_capacity[.x],
         smallest = combos$smallest[.x],
         largest = combos$largest[.x],
         fract = combos$fract[.x],
         robin_hood_mode = combos$robin_hood_mode[.x]) 

return(Out)
}) %>%
  mutate(combo = paste(carrying_capacity, smallest, largest, fract, robin_hood_mode))

test_res %>%
  ggplot(aes(x = attack_round, colour = combo)) + geom_density()

test_out <-test_res %>%
  select(combo, attack_round:nodes) %>%
    group_by(combo) %>%
  summarise_all(list(mean = mean, sd = sd)) %>%
  mutate(attack_round_ratio = attack_round_sd/attack_round_mean)

test_out %>%
  ggplot(aes(x = attack_round_ratio, y = attack_round_mean)) + geom_point()

mean(test_out$attack_round_ratio)

```


```{r}

#these are the evaluation metrics of the system
multi_metric <- metric_set(rmse, rsq, mae, smape)

```


#Aggregate and plot IEEE-118 r,c data

The results of this plot show that SETS is less affected by the change in concentration than alpha of load
```{r}
#N.B.
#The mean and median strain is the value at the loss of gc point. The correct value comes in when the strain data is added

#using the combined data frame aggregate the results by parameter group
source(file.path(CodeFolder, "sub_scripts", "process_rc_comparisons_subscript.r"))

#Raster plot that shows how r and c affect model performance
metric_performance %>%
  filter(average_type=="mean",
         metric == "strain") %>%
  group_by(.metric) %>%
  mutate(perc = ifelse(.metric =="rsq",rank(signif(-.estimate, 3)), rank(signif(.estimate, 3))),
         perc2 = .estimate/min(.estimate),
         perc2 = ifelse(perc2>2, 2, perc2)-1
         ) %>% ggplot(aes(x = factor(r), y = factor(c, levels =rev(10^(1:5))), fill= perc2, )) + geom_raster() +
  facet_wrap(~.metric) +
  geom_text(aes(label = signif(.estimate, 3))) +
    scale_fill_viridis_c(limits = c(-1, 1)) +
    labs(title = "Model performance mean tension across multiple metrics by r and c", 
       x = "range of k", 
       y = "minimum k value",
       fill = "relative Error")
ggsave(filename = file.path(FiguresFolder, "randc_performance_mean_tension.pdf"))

```

The results of the r c analysis show that the mean value of tension and strain is much more accurate than the median. What's more the matrices produced by the mean and median values are symmetric (given small variances due to convergence differences) about the minor diagonal. All the model values are equal on the Major diagonal where r = c.

The mae and rsq values are almost identical for all rc combos. the min/max is mae (0.97) rsq (0.99), for rmse there is a small difference 0.93 only smape has any substantial differences 0.82. It is worth remembering that these changed are over a search space of 3 orders of magnitude. Some of the difference could be due to differences in the residual force due to convergence.

This means that a good choice for r and c would r 1000 c = 100 or r = 10k c = 1000


#Model across all graphs

After demonstrating the effectiveness on a single graph this chunk loads the data from all graphs used in the analysis, creates the resulting scatter plots and measures the effeectiveness at modelling giant component collapse.

```{r}

non_PL_folders <- list.files(embeddings_path, full.names = T)[!grepl("PL", list.files(embeddings_path))]

all_SETSe_emebeddings <- process_all_setse_emebeddings(
  processed_path =  file.path(project_folder, "all_setse_embeddings_standard.rds"), 
  folder_paths = non_PL_folders, 
  graph_agg= all_graph_agg)

# all_SETSe_emebeddings <- process_all_setse_emebeddings(
#   processed_path =  file.path(project_folder, "all_setse_embeddings_sqrt_k.rds"),
#   folder_paths = list.files("/home/jonno/test_strain/strain_sqrt_k", full.names = T),
#   graph_agg= all_graph_agg)



```



##plot results
```{r}
unique(all_SETSe_emebeddings$metric)
use_graph <- "IEEE_118_igraph" #"UK_high_voltage"#"IEEE_300_igraph"
average_type2 <-"mean"

all_SETSe_emebeddings %>%
   filter(
     graph == use_graph,
     average_type == average_type2
          ) %>%
  mutate(metric = str_replace(metric, "_", " "),
         error_spike = carrying_capacity>1.5 & !as.logical(robin_hood_mode) & fract == 1) %>%
  ggplot(aes(x = value, y = attack_round, group = metric)) + 
  geom_point(aes( colour = as.factor(error_spike))) +
  geom_line(data = PL_SETSe_emebeddings %>%
              filter(graph == use_graph,
                     average_type == average_type2), size = 1) +
    geom_smooth(method = "loess",se = FALSE)+
  facet_wrap(~metric) +
  #facet_wrap(~metric, scales = "free_x") +
  labs(colour = "Capacity", y = "Attack round", x = "Fraction of total range")+
  labs(title = "The relationship between robustness metrics and number of attacks until failure",
          y = "Number of rounds until loss of giant component") 
ggsave(file.path(FiguresFolder, "robustness_and_attacks_118.pdf"))


#The error spikes are responsible for only 6% of the total number of cases
all_SETSe_emebeddings %>%
  mutate( error_spike = carrying_capacity>1.5 & as.logical(robin_hood_mode) & fract == 1) %>%
  group_by(error_spike) %>%
  summarise(count = n()) %>%
  mutate(perc = count/sum(count))

```


#get performance across all networks

```{r}


source(file.path(CodeFolder, "sub_scripts", "calc_model_perf_subscript.R"))

metric_performance_plot_df %>%
  filter(error_type =="standard") %>%
    #filter(combo !="mean alpha", combo != "median tension") %>%
  ggplot(aes(x = graph_order, y = rank, colour = combo, group = combo)) + geom_line() +
  facet_wrap(~eval_metric) +
 # scale_color_brewer(type = "qual") +
  theme(axis.text.x = element_text(angle = 15, hjust = 1)) +
  labs(title = "Rank of performance of robustness metrics across 4 different evaluation methods",
       y = "Rank of  robustness method",
       x = "Networks in order of complexity",
       colour = "robustness metric") +
  scale_color_brewer(palette = "Set1")
ggsave(filename = file.path(FiguresFolder, "performance_across_networks.pdf"))
  

metric_performance_plot_df %>%
  filter(error_type =="standard") %>%
  filter(combo !="mean alpha", combo != "median tension", combo !="median strain") %>%
  group_by(eval_metric) %>%
  mutate(relative_estimate = ifelse(eval_metric=="rsq", .estimate/max(.estimate), .estimate/min(.estimate))) %>%
  ggplot(aes(x = graph_order, y = relative_estimate, colour = combo, group = combo)) + geom_line() +
  facet_wrap(~eval_metric, scales = "free_y") +
  theme(axis.text.x = element_text(angle = 15, hjust = 1)) +
  labs(title = "Performance of robustness metrics across 4 different evaluation methods",
       y = "Rank of  robustness method",
       x = "Networks in order of complexity",
       colour = "robustness metric") +
  scale_color_brewer(palette = "Set1")


test <-metric_performance_plot_df %>% 
  select(-rank,-.estimator) %>%
  pivot_wider(names_from = error_type, values_from = .estimate) %>%
  mutate(change = no_spikes-standard,
         change_perc = change/standard) %>%
  filter(metric %in% c("tension","strain"))

test  %>%
 # filter(combo !="mean alpha", combo != "median tension", combo !="median strain") %>%
  group_by(eval_metric) %>%
  ggplot(aes(x = graph_order, y = change, colour = combo, group = combo)) + geom_line() +
  facet_wrap(~eval_metric, scales = "free_y") +
  theme(axis.text.x = element_text(angle = 15, hjust = 1)) +
  labs(title = "Performance of robustness metrics across 4 different evaluation methods",
       y = "Change in error",
       x = "Networks in order of complexity",
       colour = "robustness metric") +
  scale_color_brewer(palette = "Set1")
  

#metric_performance_plot_df2<- metric_performance_plot_df
```


```{r}

metric_combos <- expand_grid(
  metrics = unique(all_SETSe_emebeddings$metric),
  average_type =unique(all_SETSe_emebeddings$average_type))

metric_performance_all3 <-1:nrow(metric_combos) %>%
    map_df(~{
      print(.x)
      temp <- all_SETSe_emebeddings %>%
        filter(
         # !is.na(value),
          #fract == 1,
         # robin_hood_mode ==TRUE,
         average_type == metric_combos$average_type[.x],
          metric == metric_combos$metrics[.x]
         )  %>%
  filter(graph!="UK_high_voltage") %>%
        mutate(graph2 = as.factor(graph) %>% as.numeric())
      
      loess_mod <- loess(formula =attack_round~ value +graph2, 
                         data = temp)
      
      model_comp <- temp  %>%
        mutate(preds = predict(loess_mod)
        )
      
      multi_metric(data = model_comp, truth = attack_round, estimate = preds) %>% 
        mutate(metric = metric_combos$metrics[.x],
              average_type = metric_combos$average_type[.x])
      
    }) %>%
    mutate(combo = paste(average_type, metric)) 


metric_performance_all4 <-1:nrow(metric_combos) %>%
    map_df(~{
      print(.x)
      temp <- all_SETSe_emebeddings %>%
        filter(
      #    graph == metric_combos$graph[.x],
          average_type == metric_combos$average_type[.x],
          metric == metric_combos$metrics[.x]
        )  %>%
        filter(graph!="UK_high_voltage") %>%
        mutate(graph2 = as.factor(graph) %>% as.numeric())
      
      loess_mod <- loess(formula =attack_round~ value*graph2, 
                         data = temp)
      
      model_comp <- temp  %>%
        mutate(preds = predict(loess_mod)
        ) %>% 
        mutate(
        #     graph == metric_combos$graph[.x],
          metric = metric_combos$metrics[.x],
              average_type = metric_combos$average_type[.x])

    }) 


metric_performance_all4 %>%
  mutate(combo = paste(average_type, metric),
         error = attack_round - preds) %>%
  filter(combo %in% c("mean tension", "mean loading"))  %>%
  ggplot(aes(x = combo, y = abs(error), fill = combo)) + geom_violin() +
  facet_wrap(~graph, scales = "free")


metric_performance_all4 %>%
  mutate(combo = paste(average_type, metric),
         error = attack_round - preds) %>%
  filter(combo %in% c("mean strain", "mean loading"))  %>%
  ggplot(aes(x = error, y = attack_round, colour = as.factor(largest))) + geom_point() +
  facet_wrap(~combo, scales = "free")

test <- metric_performance_all4 %>%
  mutate(combo = paste(average_type, metric),
         error = attack_round - preds) %>%
  filter(combo %in% c("mean tension", "mean loading")) %>%
  pivot_wider(id_cols = carrying_capacity:graph, names_from = combo, values_from = error) %>%
  mutate(tension_better = abs(`mean loading`)> abs(`mean tension`))




```


The plot shows the rank performance of each robustness metric relative to the evaluation metric. Mean strain and tension are consistantly better that the other metrics with median loading outperforming mean tension only on IEEE-30. There are appears to be a link between model performance and the complexity of the network, as the networks get larger and more complex the robustness metrics consistantly change position. 

#check extremes
```{r}
 test_error <-(1:nrow(metric_combos)) %>%
    map_df(~{
#print(.x)
      temp <- all_SETSe_emebeddings %>%
        filter(
          !is.na(value),
          #fract == 1,
          average_type == metric_combos$average_type[.x],
          metric == metric_combos$metrics[.x],
          graph == metric_combos$graph[.x])
      
      
      loess_mod <- loess(formula =attack_round~ value, 
                         data = temp)
      
      model_comp <- temp  %>%
        mutate(preds = predict(loess_mod),
        error = attack_round - preds)
      
    }) %>%
    mutate(combo = paste(average_type, metric)) 


 test_error  %>%
   filter(
     graph == use_graph,
   # fract == 1,
  #  largest ==0.1,
     average_type == average_type2,
          ) %>%
  mutate(metric = str_replace(metric, "_", " "),
         error_spike = (carrying_capacity>1.5  & (fract == 1) & robin_hood_mode==TRUE)) %>%
  ggplot(aes(x = value, y = error, group = metric)) + 
  geom_point(aes( colour = as.factor(error_spike))) +
    geom_smooth(method = "loess",se = FALSE)+
  facet_wrap(~metric) +
  labs(colour = "Fraction", y = "Attack round error", x = "Fraction of total range")+
  labs(title = "Error in predicting collapse of giant component coloured by fraction of most 
       high capacity edges affected",
          y = "Error in number of rounds until loss of giant component") 
 ggsave(filename = file.path(FiguresFolder, "error_plot.pdf"))
 
 test2 <- test_error %>% 
   mutate(metric = str_replace(metric, "_", " "),
           error_spike = (carrying_capacity>1.5 & (fract == 1) & robin_hood_mode=="TRUE"),
          test = as.logical(largest) ) %>%
   filter(metric == "strain",
          average_type =="mean",
          graph == use_graph)
 
 test2 %>%
   filter(
     #fract ==1,
 #    carrying_capacity==20
    # value<0.25#,
   #  !error_spike
          ) %>%
   ggplot(aes(x = value, y = error, group = metric, colour = as.factor(fract)))+ geom_point()

 
 .x <- "/home/jonno/Dropbox/IEEE_Networks/embeddings/UK_high_voltage/fract_1_ec_20_largest_0.5_smallest_0.5_robin_hood_TRUE.rds"  
#the below results are most clear for strain but are also visible for tension
#The biggest spikes are when the distribution fraction is 1 and robin hood mode is true.
 #each individual spike is made up of one of the "largest" fractions the highest spike is 0.1 the smallest is 0.5. This is becuase the more extreme the value the more concentrated the result.
 #SETSe is a poor proxy for failure when the nodes with the most flow have the least excess capacity and the nodes with the least flow have the most excess capacity at the same time that the network overall has a low likelihood of cascades in general. In this situation the SETSe algorithm predicts cascading failures where there are unlikely to be any underestimating the robustness of the network. However this only occurs when the network has a relatively large number of edges that are not part of a cycle
 
 
test_error %>% 
   mutate(metric = str_replace(metric, "_", " ")) %>%
   filter(metric == "strain",
          average_type =="mean",
          graph == use_graph) %>%
  ggplot(aes(x  = mean_ratiostrain, y = mean_ratiotension, colour = error))+ geom_point()

 test_error %>% 
   mutate(metric = str_replace(metric, "_", " ")) %>%
   filter(metric == "strain",
          average_type =="mean",
          graph == use_graph) %>%
  ggplot(aes(x  = mean_ratiostrain, y = abs(error), colour =factor(largest)))+ geom_point()

```

##extremes map 
```{r}
library(ggraph)
graph_name <- "UK_high_voltage"
graph_name <- paste0("IEEE_", 118, "_igraph")
{
g <- read_rds(file.path(power_grid_graphs_path , paste0(graph_name, ".rds")))
 
g_df <- as_data_frame(g, what = "both")

embeddings_data <- read_rds(file.path("/home/jonno/Dropbox/IEEE_Networks/embeddings", graph_name,  "fract_1_ec_20_largest_0.1_smallest_0.5_robin_hood_TRUE.rds") )

embeddings_data_FALSE <- read_rds(file.path("/home/jonno/Dropbox/IEEE_Networks/embeddings", graph_name,  "fract_1_ec_20_largest_0.1_smallest_0.5_robin_hood_FALSE.rds") )

pl_embeddings_data <- read_rds(file.path("/home/jonno/Dropbox/IEEE_Networks/embeddings/PL", graph_name,  "ec_20.rds") )
 
g_new_df <- left_join(g_df$edges, 
          embeddings_data$edge_embeddings %>%
            select( -power_flow), by = "edge_name") %>% 
  mutate(
    power_perc = percent_rank(abs(power_flow)),
    strain_perc = percent_rank(strain),
    type = "TRUE") 

g_new_df_FALSE <- left_join(g_df$edges, 
          embeddings_data_FALSE$edge_embeddings %>%
            select( -power_flow), by = "edge_name") %>% mutate(type = "FALSE") 

pl_g_new_df<- left_join(g_df$edges, 
          pl_embeddings_data$edge_embeddings %>%
            select( -power_flow), by = "edge_name") %>% mutate(type = "PL") 

g_new_df <- left_join(g_new_df, pl_g_new_df %>% select(edge_name, 
                                          # pl_edge_capacity = edge_capacity,
                                           pl_strain = strain,
                                           pl_tension = tension)) %>%
  mutate(strain_diff = strain-pl_strain,
         strain_ratio = strain/pl_strain,
         tension_diff= tension*pl_tension,
         perc_test = log10(strain_perc)) %>%
  left_join(., embeddings_data_A3$edge_embeddings %>% select(edge_name, k_A3 = k, tension_A3 = tension, 
                                                             strain_A3 = strain)) %>%
    mutate(strain_diff3 = strain_A3-pl_strain,
         strain_ratio3 = strain_A3/pl_strain,
         tension_diff3 = tension_A3*pl_tension)



g <- g_new_df %>%
  graph_from_data_frame(., directed = F, vertices = g_df$vertices)

set.seed(158)
ggraph(g, layout = layout_with_fr(g)) +
   geom_edge_link2(aes(colour = percent_rank(strain_diff3)), width = 0.7) +
 scale_edge_colour_viridis() +
 # geom_node_point( aes(shape =  case_when(net_generation ==0 ~"Transmission",
 #                                       net_generation > 0 ~"Generation",
 #                                       TRUE ~"Demand")),
 #                  size = 2.5) +
  ggtitle("IEEE 118 power grid with Fruchtman Reingold projection")

}

g_new_df %>%
  ggplot(aes(x = (abs(k_A3)), y = abs(k), colour =strain_diff>0)) + geom_point() + 
  labs(colour = "ratio")

g_new_df %>% ggplot(aes(x = (abs(strain_diff)))) + geom_density()

bind_rows(g_new_df, pl_g_new_df, g_new_df_FALSE) %>%
  ggplot(aes(x = abs(power_flow), y =log10(tension*abs(power_flow)), colour = edge_capacity)) + geom_point() +
  facet_wrap(~type)

bind_rows(g_new_df, pl_g_new_df, g_new_df_FALSE) %>%
  group_by(type) %>%
  summarise(mean_tension = mean(log10(tension*abs(power_flow))),
            median_tension = median(log10(tension*abs(power_flow))),
            mean_strain = mean(log10(tension*abs(power_flow))),
            median_strain = median(log10(tension*abs(power_flow))))


#strain and tension both mean and median for robin_hood mode true/false and also PL
bind_rows(g_new_df, pl_g_new_df, g_new_df_FALSE) %>%
  group_by(type) %>%
  summarise(mean_tension = mean(tension),
            median_tension = median(tension),
            mean_strain = mean(strain),
            median_strain = median(strain),
            mean_strain3 = mean(strain_A3),
            mean_tension3 = mean(tension_A3))


test <-left_join(g_new_df, pl_g_new_df %>% select(edge_name, 
                                           pl_edge_capacity = edge_capacity,
                                           pl_strain = strain,
                                           pl_tension = tension)) %>%
  mutate(strain_ratio = strain/pl_strain,
         tension_ratio = tension/pl_tension)
  

test %>%
  ggplot(aes(x = pl_strain, y = strain_A3, colour = strain_ratio)) + geom_point()

g_new_df %>%
  ggplot(aes(x = strain_diff)) + geom_density()
mean(g_new_df$strain_diff)
mean(g_new_df$strain)
mean(g_new_df$pl_strain)

mean(g_new_df$strain_diff)/mean(g_new_df$pl_strain)

```




##Optional

Include the tube map as a strain graph where routes are decided based on shortest path after each attack.

```{r}

```

#UK map 

This chunk plots the UK high voltage network in geospace and shows how SETse provides interpretable results

##Set up UK Graph and SETSe
```{r}

UKg <- readRDS(file.path(power_grid_graphs_path,  paste0("UK_high_voltage.rds"))) %>%
            #    Proportional_Load(., 1, PowerFlow = "power_flow", Link.Limit = "edge_capacity") %>%
                set.edge.attribute(. , "distance", value = 1) %>%
        set.edge.attribute(., "Area", value = 1) %>%
        calc_spring_youngs_modulus(., "power_flow", "edge_capacity", minimum_value = 10000, stretch_range = 1000) %>%
        calc_spring_constant(., E ="E", A = "Area", distance = "distance") %>%
        normalise_dc_load(.,  
                           generation = "generation", 
                           demand  = "demand",
                           net_generation = "net_generation", 
                           capacity = "edge_capacity",
                           edge_name = "edge_name", 
                           node_name = "name",
                           power_flow = "power_flow")  %>%
  #prevents NaNs when edge capacity is zero
  set_edge_attr(., "edge_capacity", 
                value = ifelse(is.finite(edge_attr(.,"edge_capacity")), edge_attr(.,"edge_capacity"), 0 ) ) 

#useful at various stages
energy_types <- c("Coal", "Gas", "Renewable", "Nuclear")
sim_names <- paste0("No_", energy_types)

#takes about 60 secs
UK_SETSe_data <- auto_SETSe(UKg, 
           force ="net_generation", 
           flow = "power_flow", 
           distance = "distance", 
           capacity = "edge_capacity",
           edge_name = "edge_name",
           tstep = 0.01, 
           mass = 1, 
           max_iter = 100000, 
           tol = 2e-3,
           sparse = FALSE,
           hyper_iters = 100,
           sample = 100)

```

##Kriged map

Plot the results of the SETS embedding in geographical space. Show that this representation is interpretable
```{r}
shapefile <- file.path("/home/jonno/Dropbox/Jonathan_Bourne_Phd_Folder/ShapeFiles UK",
                       "Countries_December_2017_Ultra_Generalised_Clipped_Boundaries_in_UK_WGS84.shp")

GB <- st_read(shapefile) %>%
  filter(ctry17cd !="N92000002") %>%
  st_union()

spdf <- as(GB, "Spatial") %>% st_as_sf %>%
  st_crop(c(xmin = -7.5, ymin = 50, xmax = 2, ymax = 59)) %>%
  as_Spatial()

kriged_height_strain_data <- krige_height_strain_maps(                                                      
  SETSe_list = UK_SETSe_data, 
  coords = MakeMapDF(UKg, read_csv(file.path(basewd, "point.csv")))  %>%
    filter(PositionType=="Geo Space"), 
  spatial_df = spdf)

kriged_height_strain_data %>%
  mutate(type = fct_relevel(type, "Load", after = Inf)) %>%
  ggplot(aes(x=Longitude, y=Latitude)) + 
  geom_tile(aes(fill=value_perc)) + coord_equal() +
  facet_grid(~type) +
  scale_fill_viridis_c() +
scale_colour_viridis_c(option = "plasma") +
  labs(title = "Height and Strain of the UK high-voltage power grid under base load generation", 
       fill = "Percentile") +
  theme(axis.title = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        legend.position = "right",
        plot.margin=unit(c(-60,0,-60,0),"mm")
        ) #the legend position may want changing back to the more convential side.
  ggsave(file.path(FiguresFolder, "BritainKrigedTopology2.eps"), dpi = 600)


```


#Optional Failure groups
Optional! show the relationship between the clustering produced by SETS and failure groups, 
compare with the hierarchically clustered based on topology and seperately wieghted with edge load.
Ground truth is thr groups formed by probability of joint failure.

This block calcualtes all the data, it is very slow and so advisable to run the sourced script on an HPC
```{r}

graph_task_combos <- expand_grid(graph = c( "IEEE_14_igraph", "IEEE_30_igraph", "IEEE_57_igraph", "IEEE_118_igraph"),
         task_id = 1:10)

for(i in 1:nrow(graph_task_combos)){
  
  task_id <- graph_task_combos$task_id[i] #this is the compute group to be used
  
  load_file <- graph_task_combos$graph[i]

  source(file.path("/home/jonno/setse_and_network_robustness/HPC_files", "HPC_attack_random.R"), local = TRUE)
  
} 





```

##Load the failure groups
This chunk loads the co failures by graph into fully stacked o_failure matrices
```{r}
#create cluster matrix
full_mat_list <- return_full_co_failure_list(
  folder = file.path("/home/jonno/Dropbox/IEEE_Networks/ten_k_attacks", "IEEE_118_igraph"), pattern = "co_failure")

clust_data <- full_mat_list$node_co_failure
#self links are meaningless and so are set to 0
diag(clust_data) <- 0

#the fraction of times the co-failure DID NOT occure, this is equivalent to the distance
#100% did occur is distance 0 whilst 100% did not co-occur is distance 1
clust_data <- (10000-clust_data)/10000
#clust_data <- clust_data*as_adjacency_matrix(g)

clust_data <- (clust_data)
clust_data <- as.dist(clust_data, diag = FALSE)

clust_tree <- hclust(clust_data, method = "single")


plot(clust_tree)
cutree(clust_tree, k = 30)

current_graph <- Proportional_Load(g, alpha = 2, PowerFlow = "power_flow", Link.Limit = "edge_capacity") %>%
  set.edge.attribute(. , "distance", value = 1) %>%
  set.edge.attribute(., "Area", value = 1) %>%
  calc_spring_youngs_modulus(., "power_flow", "edge_capacity", minimum_value = 1100, stretch_range = 1000) %>%
  calc_spring_constant(., E ="E", A = "Area", distance = "distance") %>%
  normalise_dc_load(.,  
                    generation = "generation", 
                    demand  = "demand",
                    net_generation = "net_generation", 
                    capacity = "edge_capacity",
                    edge_name = "edge_name", 
                    node_name = "name",
                    power_flow = "power_flow")

embeddings_data <- auto_SETSe(current_graph, 
                              force ="net_generation", 
                              flow = "power_flow", 
                              distance = "distance", 
                              capacity = "edge_capacity",
                              edge_name = "edge_name",
                              tstep = 0.01, 
                              mass = 1, 
                              max_iter = 30000, 
                              tol = 2e-3,
                              sparse = FALSE,
                              hyper_iters = 100,
                              sample = 100)
  


g_edge_df_temp  <- as_data_frame(g) %>%
  left_join(embeddings_data$edge_embeddings %>% select(-power_flow, -edge_capacity))

test <- graph_from_data_frame(g_edge_df_temp, directed = FALSE) %>%
  as_adjacency_matrix(., attr = "tension" ) %>% as.matrix()
clust_data <- test

library(dendextend)

entanglement(clust_tree, clust_tree2)
tanglegram(clust_tree, clust_tree2)

```


```{r}

total_time <- system.time(out<- auto_SETSe(g, max_iter = 1e5))
```


#package update
This chunk is the code to quickly update the package
```{r}
library(devtools)
library(roxygen2)
roxygenise( "/home/jonno/NetworkSpringEmbedding")
detach("package:NetworkSpringEmbedding", unload = TRUE)
install("~/NetworkSpringEmbedding")
library(NetworkSpringEmbedding)
```

